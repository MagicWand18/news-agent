generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Organization {
  id          String       @id @default(cuid())
  name        String
  maxClients  Int?         // Límite de clientes (null = sin límite)
  createdAt   DateTime     @default(now())
  users       User[]
  clients     Client[]
  competitors Competitor[]
  orgTelegramRecipients OrgTelegramRecipient[]
}

model User {
  id             String         @id @default(cuid())
  name           String
  email          String?        @unique
  passwordHash   String?
  telegramUserId String?        @unique
  role           Role           @default(ANALYST)
  orgId          String?
  org            Organization?  @relation(fields: [orgId], references: [id])
  assignedTasks  Task[]
  notifications  Notification[]
  createdAt      DateTime       @default(now())

  // Super Admin y Onboarding
  isSuperAdmin         Boolean          @default(false)
  onboardingStatus     OnboardingStatus @default(PENDING)
  onboardingCompletedAt DateTime?

  // Action Pipeline
  responseDraftsCreated  ResponseDraft[] @relation("ResponseCreatedBy")
  responseDraftsApproved ResponseDraft[] @relation("ResponseApprovedBy")
  crisisAssigned         CrisisAlert[]   @relation("CrisisAssignedTo")
  crisisNotes            CrisisNote[]
  actionItems            ActionItem[]
  campaignNotes          CampaignNote[]

  // Preferencias de notificaciones Telegram para SuperAdmins
  telegramNotifPrefs     Json?           // { "MENTION_ALERT": true, "DAILY_DIGEST": false, ... } null = todo ON

  // Shared Reports
  sharedReports          SharedReport[]
}

enum Role {
  ADMIN
  SUPERVISOR
  ANALYST
}

enum OnboardingStatus {
  PENDING      // No ha iniciado el onboarding
  IN_PROGRESS  // Está en el tour
  COMPLETED    // Completó el tour
  SKIPPED      // Saltó el tour
}

model Client {
  id              String          @id @default(cuid())
  name            String
  description     String?
  industry        String?
  telegramGroupId String?         // LEGACY: usar telegramRecipients
  clientGroupId   String?         // LEGACY: usar telegramRecipients
  active          Boolean         @default(true)
  orgId           String
  org             Organization    @relation(fields: [orgId], references: [id])
  keywords        Keyword[]
  mentions        Mention[]
  tasks           Task[]
  crisisAlerts    CrisisAlert[]
  reportLogs      ReportLog[]
  weeklyInsights  WeeklyInsight[]
  onboarding      Json?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Sprint 9: Múltiples destinatarios de Telegram
  telegramRecipients TelegramRecipient[]

  // Grounding Config - Configuración de búsqueda automática con Gemini
  groundingEnabled         Boolean   @default(false)  // Habilitar grounding automático
  minDailyMentions         Int       @default(3)      // Mínimo de menciones diarias esperadas
  consecutiveDaysThreshold Int       @default(3)      // Días consecutivos bajo umbral para disparar
  groundingArticleCount    Int       @default(10)     // Artículos a buscar en cada grounding
  weeklyGroundingEnabled   Boolean   @default(false)  // Habilitar grounding semanal programado
  weeklyGroundingDay       Int       @default(0)      // Día de la semana (0=domingo, 6=sábado)
  lastGroundingAt          DateTime?                  // Última ejecución de grounding
  lastGroundingResult      Json?                      // Resultado de la última búsqueda

  // Competitors
  competitors ClientCompetitor[]

  // Social Media Monitoring Config
  socialMonitoringEnabled Boolean   @default(false)  // Habilitar monitoreo de redes sociales
  socialHashtags          String[]  @default([])     // Hashtags a monitorear (sin #)
  socialAccounts          SocialAccount[]
  socialMentions          SocialMention[]
  lastSocialCollectionAt  DateTime?                  // Última recolección manual de redes sociales

  // Action Pipeline
  actionItems  ActionItem[]
  alertRules   AlertRule[]

  // Daily Briefs
  dailyBriefs  DailyBrief[]

  // Campaigns
  campaigns    Campaign[]

  // Shared Reports
  sharedReports SharedReport[]
}

model Keyword {
  id       String      @id @default(cuid())
  word     String
  type     KeywordType @default(NAME)
  clientId String
  client   Client      @relation(fields: [clientId], references: [id])
  active   Boolean     @default(true)

  @@unique([word, clientId])
}

enum KeywordType {
  NAME
  BRAND
  COMPETITOR // Se mantiene temporalmente hasta migrar datos existentes
  TOPIC
  ALIAS
}

model Article {
  id          String    @id @default(cuid())
  url         String    @unique
  title       String
  source      String
  content     String?
  contentHash String?
  publishedAt DateTime?
  collectedAt DateTime  @default(now())
  mentions    Mention[]
}

model Mention {
  id             String    @id @default(cuid())
  articleId      String
  article        Article   @relation(fields: [articleId], references: [id])
  clientId       String
  client         Client    @relation(fields: [clientId], references: [id])
  keywordMatched String
  snippet        String?
  sentiment      Sentiment @default(NEUTRAL)
  relevance      Int       @default(5)
  aiSummary      String?
  aiAction       String?
  urgency        Urgency   @default(MEDIUM)
  notified       Boolean   @default(false)
  notifiedAt     DateTime?
  clientNotified Boolean   @default(false)
  createdAt      DateTime  @default(now())
  tasks          Task[]
  responseDrafts ResponseDraft[]
  campaignMentions CampaignMention[]

  // Legacy: artículo publicado antes de que el cliente fuera creado (contexto histórico)
  isLegacy       Boolean   @default(false)

  // Fecha de publicación del artículo (denormalizada de Article.publishedAt para queries temporales)
  publishedAt    DateTime?

  // Clustering
  parentMentionId String?
  parentMention   Mention?  @relation("MentionCluster", fields: [parentMentionId], references: [id])
  childMentions   Mention[] @relation("MentionCluster")
  clusterScore    Float?

  // Topic clustering (Sprint 6)
  topic          String?
  topicClusterId String?
  topicCluster   TopicCluster? @relation(fields: [topicClusterId], references: [id])

  @@index([clientId, createdAt])
  @@index([clientId, isLegacy, createdAt])
  @@index([parentMentionId])
  @@index([clientId, parentMentionId, createdAt])
  @@index([topicClusterId])
  @@index([clientId, publishedAt])
  @@index([clientId, isLegacy, publishedAt])
  @@index([clientId, parentMentionId, publishedAt])
}

enum Sentiment {
  POSITIVE
  NEGATIVE
  NEUTRAL
  MIXED
}

enum Urgency {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

model Task {
  id              String         @id @default(cuid())
  title           String
  description     String?
  status          TaskStatus     @default(PENDING)
  priority        Priority       @default(MEDIUM)
  deadline        DateTime?
  clientId        String?
  client          Client?        @relation(fields: [clientId], references: [id])
  mentionId       String?
  mention         Mention?       @relation(fields: [mentionId], references: [id])
  socialMentionId String?
  socialMention   SocialMention? @relation(fields: [socialMentionId], references: [id])
  assigneeId      String?
  assignee        User?          @relation(fields: [assigneeId], references: [id])
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  completedAt     DateTime?

  @@index([assigneeId, status])
  @@index([clientId, status])
  @@index([socialMentionId])
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Priority {
  URGENT
  HIGH
  MEDIUM
  LOW
}

model DigestLog {
  id                 String   @id @default(cuid())
  clientId           String
  type               String
  articleCount       Int
  socialMentionCount Int      @default(0)
  sentAt             DateTime @default(now())
}

model Setting {
  id          String      @id @default(cuid())
  key         String      @unique
  value       String
  type        SettingType @default(STRING)
  category    String      @default("general")
  label       String?
  description String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

enum SettingType {
  STRING
  NUMBER
  BOOLEAN
  JSON
}

model CrisisAlert {
  id            String            @id @default(cuid())
  clientId      String
  client        Client            @relation(fields: [clientId], references: [id])
  triggerType   CrisisTriggerType
  mentionCount  Int
  severity      CrisisSeverity    @default(HIGH)
  status        CrisisStatus      @default(ACTIVE)
  resolvedAt    DateTime?
  resolvedBy    String?
  notes         String?
  notified      Boolean           @default(false)
  notifiedAt    DateTime?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  // Action Pipeline
  assignedToId  String?
  assignedTo    User?             @relation("CrisisAssignedTo", fields: [assignedToId], references: [id])
  crisisNotes   CrisisNote[]
  campaigns     Campaign[]

  @@index([clientId, status])
  @@index([createdAt])
}

enum CrisisTriggerType {
  NEGATIVE_SPIKE
  HIGH_VOLUME
  CRITICAL_SOURCE
  MANUAL
}

enum CrisisSeverity {
  CRITICAL
  HIGH
  MEDIUM
}

enum CrisisStatus {
  ACTIVE
  MONITORING
  RESOLVED
  DISMISSED
}

model ReportLog {
  id           String   @id @default(cuid())
  clientId     String
  client       Client   @relation(fields: [clientId], references: [id])
  type         String   // "weekly" | "monthly"
  mentionCount Int
  sentAt       DateTime @default(now())

  @@index([clientId, sentAt])
}

// Sprint 6: Media Intelligence Avanzada

// Tier de fuentes por alcance
model SourceTier {
  id        String   @id @default(cuid())
  domain    String   @unique // ej: "elpais.com"
  name      String            // ej: "El País"
  tier      Int      @default(3) // 1=nacional, 2=regional, 3=digital
  reach     Int?              // alcance estimado (opcional)
  createdAt DateTime @default(now())

  @@index([tier])
}

// Cluster de temas detectados
model TopicCluster {
  id        String    @id @default(cuid())
  name      String             // ej: "Fusión empresarial"
  mentions  Mention[]
  count     Int       @default(0) // Contador de menciones
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([name])
  @@index([createdAt])
}

// Insights semanales generados por IA
model WeeklyInsight {
  id        String   @id @default(cuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id])
  weekStart DateTime
  insights  Json     // Array de recomendaciones
  sovData   Json     // Datos de SOV de esa semana
  topTopics Json     // Temas más frecuentes
  createdAt DateTime @default(now())

  @@unique([clientId, weekStart])
  @@index([clientId, weekStart])
}

// Sprint 7: Notificaciones de temas emergentes
model EmergingTopicNotification {
  id           String   @id @default(cuid())
  clientId     String
  topic        String
  mentionCount Int
  createdAt    DateTime @default(now())

  @@index([clientId, topic, createdAt])
}

// Sprint 8: Fuentes RSS expandidas
model RssSource {
  id         String     @id @default(cuid())
  name       String
  url        String     @unique
  tier       Int        @default(3) // 1=nacional, 2=estatal, 3=municipal
  type       SourceType @default(NATIONAL)
  state      String?    // NULL para nacionales
  city       String?    // NULL para estatales/nacionales
  active     Boolean    @default(true)
  lastFetch  DateTime?
  errorCount Int        @default(0)
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@index([type, state])
  @@index([active])
}

enum SourceType {
  NATIONAL    // Medios nacionales
  STATE       // Medios estatales
  MUNICIPAL   // Medios municipales
  SPECIALIZED // Negocios, deportes, tech
}

// Sprint 8: Sistema de solicitud de fuentes
model SourceRequest {
  id          String        @id @default(cuid())
  name        String
  url         String
  state       String?
  city        String?
  requestedBy String        // userId
  status      RequestStatus @default(PENDING)
  notes       String?
  reviewedBy  String?       // adminId
  reviewedAt  DateTime?
  createdAt   DateTime      @default(now())

  @@index([status])
  @@index([requestedBy])
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
  INTEGRATED
}

// Sprint: Google News RSS para fuentes sin feed propio
model NoRssSource {
  id         String     @id @default(cuid())
  name       String
  domain     String     @unique  // eluniversal.com.mx
  tier       Int        @default(1) // 1=nacional, 2=estatal
  type       SourceType @default(NATIONAL)
  state      String?    // NULL para nacionales
  active     Boolean    @default(true)
  lastFetch  DateTime?
  errorCount Int        @default(0)
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@index([active])
  @@index([type, state])
}

// Sprint 9: Sistema de múltiples destinatarios de Telegram

model TelegramRecipient {
  id        String        @id @default(cuid())
  clientId  String
  client    Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  chatId    String        // Telegram chat ID (grupo o usuario)
  type      RecipientType
  label     String?       // Etiqueta descriptiva ej: "Grupo Interno", "Juan Pérez (CMO)"
  active    Boolean       @default(true)
  addedBy   String?       // userId que lo agregó
  createdAt DateTime      @default(now())

  @@unique([clientId, chatId])
  @@index([clientId, active])
  @@index([type])
}

enum RecipientType {
  AGENCY_INTERNAL   // Grupo interno del equipo de la agencia
  CLIENT_GROUP      // Grupo compartido con el cliente
  CLIENT_INDIVIDUAL // Usuario individual del lado del cliente
}

// Sprint 10: Notificaciones In-App

model Notification {
  id        String           @id @default(cuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String
  data      Json?
  read      Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())

  @@index([userId, read])
  @@index([userId, createdAt])
}

enum NotificationType {
  MENTION_CRITICAL   // Mención crítica detectada
  MENTION_HIGH       // Mención de alta prioridad
  CRISIS_ALERT       // Alerta de crisis
  WEEKLY_REPORT      // Reporte semanal disponible
  EMERGING_TOPIC     // Tema emergente detectado
  SYSTEM             // Notificación del sistema
}

// ==================== COMPETITORS ====================

model Competitor {
  id          String             @id @default(cuid())
  name        String
  description String?
  orgId       String
  org         Organization       @relation(fields: [orgId], references: [id])
  createdAt   DateTime           @default(now())
  clients     ClientCompetitor[]

  @@unique([name, orgId])
  @@index([orgId])
}

model ClientCompetitor {
  id           String     @id @default(cuid())
  clientId     String
  client       Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  competitorId String
  competitor   Competitor @relation(fields: [competitorId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())

  @@unique([clientId, competitorId])
  @@index([clientId])
  @@index([competitorId])
}

// ==================== SOCIAL MEDIA MONITORING ====================

enum SocialPlatform {
  TWITTER
  INSTAGRAM
  TIKTOK
  YOUTUBE
}

enum SocialSourceType {
  HANDLE    // Cuenta específica monitoreada
  HASHTAG   // Hashtag monitoreado
  KEYWORD   // Búsqueda por keyword
}

// Cuenta de red social asociada a un cliente
model SocialAccount {
  id             String         @id @default(cuid())
  clientId       String
  client         Client         @relation(fields: [clientId], references: [id], onDelete: Cascade)
  platform       SocialPlatform
  handle         String         // @username sin el @
  platformUserId String?        // ID numérico del usuario en la plataforma
  label          String?        // Etiqueta descriptiva (ej: "Cuenta oficial", "CEO")
  isOwned        Boolean        @default(false) // true = cuenta del cliente, false = competidor/influencer
  active         Boolean        @default(true)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@unique([clientId, platform, handle])
  @@index([clientId, active])
  @@index([platform])
}

// Mención detectada en redes sociales
model SocialMention {
  id             String         @id @default(cuid())
  clientId       String
  client         Client         @relation(fields: [clientId], references: [id], onDelete: Cascade)
  platform       SocialPlatform
  postId         String         // ID único del post en la plataforma
  postUrl        String         // URL directa al post
  content        String?        // Texto del post (caption, tweet, etc)
  authorHandle   String         // @username del autor
  authorName     String?        // Nombre display del autor
  authorFollowers Int?          // Seguidores del autor al momento de captura

  // Métricas de engagement
  likes          Int            @default(0)
  comments       Int            @default(0)
  shares         Int            @default(0) // retweets, reposts
  views          Int?           // Para TikTok/Instagram Reels

  // Source tracking
  sourceType     SocialSourceType
  sourceValue    String         // El handle/hashtag/keyword que lo encontró

  // AI Analysis
  sentiment      Sentiment      @default(NEUTRAL)
  relevance      Int            @default(5)
  aiSummary      String?
  analyzed       Boolean        @default(false)

  // Notification status
  notified       Boolean        @default(false)
  notifiedAt     DateTime?

  // Timestamps
  postedAt       DateTime?      // Cuando se publicó el post
  collectedAt    DateTime       @default(now())
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  // Historial: mención archivada (> 30 días o anterior al cliente)
  isLegacy            Boolean     @default(false)

  // Comments extraction (Sprint: Social Comments)
  commentsData        Json?       // Array de comentarios extraídos [{commentId, text, authorHandle, likes, postedAt}]
  commentsCount       Int?        // Cantidad de comentarios extraídos
  commentsExtractedAt DateTime?   // Timestamp de extracción de comentarios
  commentsSentiment   Sentiment?  // Sentimiento agregado de los comentarios
  commentsAnalyzed    Boolean     @default(false) // Si los comentarios fueron analizados

  // Action Pipeline
  responseDrafts ResponseDraft[]
  tasks          Task[]
  campaignSocialMentions CampaignSocialMention[]

  @@unique([platform, postId])
  @@index([clientId, createdAt])
  @@index([clientId, isLegacy, createdAt])
  @@index([clientId, platform, createdAt])
  @@index([platform, postedAt])
  @@index([sentiment, createdAt])
}

// ==================== ACTION PIPELINE ====================

enum ResponseStatus {
  DRAFT
  IN_REVIEW
  APPROVED
  PUBLISHED
  DISCARDED
}

model ResponseDraft {
  id              String         @id @default(cuid())
  mentionId       String?
  socialMentionId String?
  title           String
  body            String         @db.Text
  tone            String
  audience        String
  callToAction    String
  keyMessages     String[]
  status          ResponseStatus @default(DRAFT)
  createdById     String
  approvedById    String?
  approvedAt      DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  mention         Mention?       @relation(fields: [mentionId], references: [id])
  socialMention   SocialMention? @relation(fields: [socialMentionId], references: [id])
  createdBy       User           @relation("ResponseCreatedBy", fields: [createdById], references: [id])
  approvedBy      User?          @relation("ResponseApprovedBy", fields: [approvedById], references: [id])

  @@index([mentionId])
  @@index([socialMentionId])
  @@index([status])
  @@index([createdById])
}

model CrisisNote {
  id            String      @id @default(cuid())
  crisisAlertId String
  userId        String
  content       String      @db.Text
  type          String      @default("NOTE")
  createdAt     DateTime    @default(now())

  crisisAlert   CrisisAlert @relation(fields: [crisisAlertId], references: [id])
  user          User        @relation(fields: [userId], references: [id])

  @@index([crisisAlertId, createdAt])
}

enum ActionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  NOT_APPLICABLE
}

model ActionItem {
  id          String       @id @default(cuid())
  clientId    String
  source      String
  sourceId    String?
  description String
  status      ActionStatus @default(PENDING)
  assigneeId  String?
  completedAt DateTime?
  createdAt   DateTime     @default(now())

  client      Client       @relation(fields: [clientId], references: [id])
  assignee    User?        @relation(fields: [assigneeId], references: [id])

  @@index([clientId, status])
  @@index([assigneeId])
}

enum AlertRuleType {
  NEGATIVE_SPIKE
  SOV_DROP
  VOLUME_SURGE
  COMPETITOR_SPIKE
  SENTIMENT_SHIFT
  NO_MENTIONS
}

model AlertRule {
  id        String        @id @default(cuid())
  clientId  String
  name      String
  type      AlertRuleType
  condition Json
  channels  String[]
  active    Boolean       @default(true)
  createdAt DateTime      @default(now())

  client    Client        @relation(fields: [clientId], references: [id])

  @@index([clientId, active])
}

// ==================== DAILY BRIEFS ====================

model DailyBrief {
  id        String   @id @default(cuid())
  clientId  String
  client    Client   @relation(fields: [clientId], references: [id])
  date      DateTime // Fecha del brief (inicio del día)
  content   Json     // { highlights, comparison, watchList, emergingTopics, pendingActions }
  stats     Json     // { mentions, sentiment, sov, socialPosts, engagement }
  createdAt DateTime @default(now())

  @@unique([clientId, date])
  @@index([clientId, date])
}

// ==================== CAMPAIGNS ====================

enum CampaignStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

model Campaign {
  id             String         @id @default(cuid())
  name           String
  description    String?
  clientId       String
  client         Client         @relation(fields: [clientId], references: [id])
  status         CampaignStatus @default(DRAFT)
  startDate      DateTime?
  endDate        DateTime?
  objectives     Json?          // { goals: string[], targetMetrics: {...} }
  tags           String[]       @default([])
  crisisAlertId  String?        // Campaña originada por una crisis
  crisisAlert    CrisisAlert?   @relation(fields: [crisisAlertId], references: [id])
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  mentions       CampaignMention[]
  socialMentions CampaignSocialMention[]
  notes          CampaignNote[]

  @@index([clientId, status])
  @@index([clientId, startDate])
  @@index([crisisAlertId])
}

model CampaignMention {
  id         String   @id @default(cuid())
  campaignId String
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  mentionId  String
  mention    Mention  @relation(fields: [mentionId], references: [id])
  assignedAt DateTime @default(now())

  @@unique([campaignId, mentionId])
  @@index([mentionId])
}

model CampaignSocialMention {
  id              String        @id @default(cuid())
  campaignId      String
  campaign        Campaign      @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  socialMentionId String
  socialMention   SocialMention @relation(fields: [socialMentionId], references: [id])
  assignedAt      DateTime      @default(now())

  @@unique([campaignId, socialMentionId])
  @@index([socialMentionId])
}

model CampaignNote {
  id         String   @id @default(cuid())
  campaignId String
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  content    String
  authorId   String
  author     User     @relation(fields: [authorId], references: [id])
  createdAt  DateTime @default(now())

  @@index([campaignId, createdAt])
}

// ==================== ORG-LEVEL TELEGRAM RECIPIENTS ====================

model OrgTelegramRecipient {
  id          String       @id @default(cuid())
  orgId       String
  org         Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  chatId      String
  label       String?
  active      Boolean      @default(true)
  addedBy     String?
  preferences Json?        // { "MENTION_ALERT": true, "DAILY_DIGEST": false, ... } null = todo ON
  createdAt   DateTime     @default(now())

  @@unique([orgId, chatId])
  @@index([orgId, active])
}

// ==================== SHARED REPORTS ====================

enum ReportType {
  CAMPAIGN
  BRIEF
  CLIENT_SUMMARY
}

model SharedReport {
  id          String     @id @default(cuid())
  publicId    String     @unique @default(cuid())
  clientId    String
  client      Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  type        ReportType
  title       String
  data        Json       // Snapshot de los datos al momento de generar
  createdBy   String
  creator     User       @relation(fields: [createdBy], references: [id])
  expiresAt   DateTime   // 7 días por defecto
  createdAt   DateTime   @default(now())

  @@index([publicId])
  @@index([clientId])
  @@index([expiresAt])
}
